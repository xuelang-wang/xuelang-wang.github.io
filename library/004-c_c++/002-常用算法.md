# 常用算法

## 逆波兰算法

### 中缀表达式转后缀表达式（逆波兰表达式）

1. 从左至右扫描一中缀表达式。
2. 若读取的是操作数，则判断该操作数的类型，并将该操作数存入操作数堆栈
3. 若读取的是运算符

    (1) 该运算符为左括号"("，则直接存入运算符堆栈。 
    
    (2) 该运算符为右括号")"，则输出运算符堆栈中的运算符到操作数堆栈，直到遇到左括号"("为止，此时抛弃该左括号。
      
    (3) 该运算符为非括号运算符：
        
        (a) 若运算符堆栈栈顶的运算符为左括号，则直接存入运算符堆栈
      
        (b) 若比运算符堆栈栈顶的运算符优先级高，则直接存入运算符堆栈。
        
        (c) 若比运算符堆栈栈顶的运算符优先级低或相等，则输出栈顶运算符到操作数堆栈，直至运算符栈栈顶运算符**低于（不包括等于）**该运算符优先级,或为左括号，
           并将当前运算符压入运算符堆栈。
4. 当表达式读取完成后运算符堆栈中尚有运算符时，则依序取出运算符到操作数堆栈，直到运算符堆栈为空。

例子: 中缀表达式(a+b)*c-(a+b)/e的逆波兰式是ab+c*ab+e/

### 逆波兰表达式求值

1. 初始化一个栈S
2. 从左到右遍历逆波兰表达式
   1. 遇到操作数，则存到栈S中
   2. 遇到操作符Op，则调用栈S中两个元素S[top-1] Op S[top], 计算结果存入栈S中
3. 返回栈顶元素

【练习】[150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/submissions/)

### 算法实现

#### c

```c

```

#### c++

```c++
#include<iostream>
#include<string>
#include<stack>
#include<vector>
#include<stdlib.h>

using namespace std;

int Precode(const char &ch)
{
    switch (ch) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        default:
            return 0;
    }
}

/*中缀表达式转后缀表达式(不考虑负数，且中缀表达式合理)*/
vector<string> RBNExp(string exp)
{

    vector<string> retExp;
    stack<string> opStack;
    opStack.push("#");
    for (unsigned int i = 0; i < exp.size(); i++) {
        switch (exp[i]) {
            case '(':
                opStack.push("(");
                break;
            case ')':
                while(opStack.top() != string("(")) {
                    retExp.push_back(opStack.top());
                    opStack.pop();
                }
                opStack.pop();
                break;
            case '+':
            case '-':
            case '*':
            case '/':
                while (Precode(opStack.top()[0]) >= Precode(exp[i])) {
                    retExp.push_back(opStack.top());
                    opStack.pop();
                }
                opStack.push(string("") + exp[i]);
                break;
            default:
                string tempStr;
                while (isdigit(exp[i])){
                    tempStr += exp[i];
                    i++;
                }
                i--; // 抵消for循环的一次递增
                retExp.push_back(tempStr);
                break;
        }
    }

    while (opStack.top() != string("#")){
        retExp.push_back(opStack.top());
        opStack.pop();
    }

    return retExp;
}

/*后缀表达式合理*/
float evalRPN(vector<string> vecStr)
{
    stack<float> ret;
    float num1, num2;
    for (vector<string>::iterator iter = vecStr.begin(); iter != vecStr.end(); iter++) {
        if (isdigit((*iter)[0]) || ((*iter)[0] == '-' && iter->size() > 1)) {
            ret.push(float(atoi(iter->c_str())));
        } else {
            num2 = ret.top();
            ret.pop();
            num1 = ret.top();
            ret.pop();
            if (*iter == string("+")) {
                ret.push(num1 + num2);
            } else if (*iter == string("-")) {
                ret.push(num1 - num2);
            } else if (*iter == string("*")) {
                ret.push(num1 * num2);
            } else if (int(num2) != 0){
                ret.push(num1 / num2);
            }
        }
    }
    return ret.top();
}

int main()
{
    string exp("1+2*2+4");
    vector<string> vecStr = RBNExp(exp);
    float ret = evalRPN(vecStr);
    return 0;
}
```