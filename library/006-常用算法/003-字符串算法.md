# 字符串算法

>1. [最短回文串](#最短回文串 "最短回文串")
	1. [](# "")
	1. [c](#c "c")
1. [至少k个重复字符的最长子串](#至少k个重复字符的最长子串 "至少k个重复字符的最长子串")
	1. [递归](#递归 "递归")
	1. [c实现](#c实现 "c实现")

## 最短回文串 

给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。

```
// 例子
1. "aacecaaa" ===> "aaacecaaa"
2. "abcd"     ===> "abcdcba"
```

### 

### c

```c

```

## 至少k个重复字符的最长子串

找到给定字符串（由小写字符组成）中的最长子串 T ， 要求 T 中的每一字符出现次数都不少于 k 。输出 T 的长度。

示例
```
输入:
s = "ababbc", k = 2

输出:
5

最长子串为 "ababb" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。
```

### 递归

1. 遍历字符串s, 统计字符出现次数
2. 注意剪枝，两端不符合要求的字符可以去掉
3. 从头遍历字符串s, 若当前字符ch出现次数count(ch)小于k，则将字符s以字符ch为界，切分为两个字符子串s1,s2,递归s1和s2;若整个字符串s中的字符都满足，则返回字符串长度。

### c实现

```c
#include<stdio.h>
#include<string.h>

#define NUM 26
#define MAX(a, b) ((a) > (b) ? (a) : (b))

int longestSubstringRA(char *s, int start, int end, int k)
{
    int i, j;
    int count[NUM] = {0};

    if (s == NULL || (end - start) < k) {
        return 0;
    }
    for (i = start; i < end; i++) {
        count[s[i] - 'a']++;
    }

    while (end - start >= k && count[s[start] - 'a'] < k) {
        start++;
    }
    while (end - start >= k && count[s[end - 1] - 'a'] < k) {
        end--;
    }
    if (end - start < k) {
        return 0;
    }
    
    for (i = start; i < end; i++) {
        if (count[s[i] - 'a'] < k) {
            return MAX(longestSubstringRA(s, start, i, k), longestSubstringRA(s, i + 1, end, k));
        }
    }
    return (int)(end - start);
}

int longestSubstring(char *s, int k)
{
    return longestSubstringRA(s, 0, strlen(s), k);
}

int main()
{
    char *s = "aaaaaaaaaaaaaaaabbbbbbbbbbbbaaaaaaabbbbbbbbbbbbcccccccccccdddddddddddddddddddeeeeeeeeeeeeeeefffffffffffffffgggggggggggggggggggghhhhhhhhhhhhhhhhiiiiiiiiiiiiiiiiiiiiiijjjjjjjjjjjjjjjjjjjjjjjjkkkkkkkkkkkkkkkkkkkk";
    int ret = longestSubstring(s, 10);
    return 0;
}
```


