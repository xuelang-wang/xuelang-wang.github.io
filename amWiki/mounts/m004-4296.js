if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m004']=[{"name":"001-cmake_make.md","path":"004-c_c++/001-cmake_make.md","content":"## 基础\r\n\r\n### cmake和make的区别\r\n\r\n- cmake依据cmakelists输出makefile或project文件\r\n- make依据makefile实现自动化编译\r\n","timestamp":1571152866839},{"name":"002-常用算法.md","path":"004-c_c++/002-常用算法.md","content":"# 常用算法\r\n\r\n## 逆波兰算法\r\n\r\n### 中缀表达式转后缀表达式（逆波兰表达式）\r\n\r\n1. 从左至右扫描一中缀表达式。\r\n2. 若读取的是操作数，则判断该操作数的类型，并将该操作数存入操作数堆栈\r\n3. 若读取的是运算符\r\n\r\n    (1) 该运算符为左括号\"(\"，则直接存入运算符堆栈。 \r\n    \r\n    (2) 该运算符为右括号\")\"，则输出运算符堆栈中的运算符到操作数堆栈，直到遇到左括号\"(\"为止，此时抛弃该左括号。\r\n      \r\n    (3) 该运算符为非括号运算符：\r\n        \r\n        (a) 若运算符堆栈栈顶的运算符为左括号，则直接存入运算符堆栈\r\n      \r\n        (b) 若比运算符堆栈栈顶的运算符优先级高，则直接存入运算符堆栈。\r\n        \r\n        (c) 若比运算符堆栈栈顶的运算符优先级低或相等，则输出栈顶运算符到操作数堆栈，直至运算符栈栈顶运算符**低于（不包括等于）**该运算符优先级,或为左括号，\r\n           并将当前运算符压入运算符堆栈。\r\n4. 当表达式读取完成后运算符堆栈中尚有运算符时，则依序取出运算符到操作数堆栈，直到运算符堆栈为空。\r\n\r\n例子: 中缀表达式(a+b)*c-(a+b)/e的逆波兰式是ab+c*ab+e/\r\n\r\n### 逆波兰表达式求值\r\n\r\n1. 初始化一个栈S\r\n2. 从左到右遍历逆波兰表达式\r\n   1. 遇到操作数，则存到栈S中\r\n   2. 遇到操作符Op，则调用栈S中两个元素S[top-1] Op S[top], 计算结果存入栈S中\r\n3. 返回栈顶元素\r\n\r\n【练习】[150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/submissions/)\r\n\r\n### 算法实现\r\n\r\n#### c\r\n\r\n```c\r\n\r\n```\r\n\r\n#### c++\r\n\r\n```c++\r\n#include<iostream>\r\n#include<string>\r\n#include<stack>\r\n#include<vector>\r\n#include<stdlib.h>\r\n\r\nusing namespace std;\r\n\r\nint Precode(const char &ch)\r\n{\r\n    switch (ch) {\r\n        case \'+\':\r\n        case \'-\':\r\n            return 1;\r\n        case \'*\':\r\n        case \'/\':\r\n            return 2;\r\n        default:\r\n            return 0;\r\n    }\r\n}\r\n\r\n/*中缀表达式转后缀表达式(不考虑负数，且中缀表达式合理)*/\r\nvector<string> RBNExp(string exp)\r\n{\r\n\r\n    vector<string> retExp;\r\n    stack<string> opStack;\r\n    opStack.push(\"#\");\r\n    for (unsigned int i = 0; i < exp.size(); i++) {\r\n        switch (exp[i]) {\r\n            case \'(\':\r\n                opStack.push(\"(\");\r\n                break;\r\n            case \')\':\r\n                while(opStack.top() != string(\"(\")) {\r\n                    retExp.push_back(opStack.top());\r\n                    opStack.pop();\r\n                }\r\n                opStack.pop();\r\n                break;\r\n            case \'+\':\r\n            case \'-\':\r\n            case \'*\':\r\n            case \'/\':\r\n                while (Precode(opStack.top()[0]) >= Precode(exp[i])) {\r\n                    retExp.push_back(opStack.top());\r\n                    opStack.pop();\r\n                }\r\n                opStack.push(string(\"\") + exp[i]);\r\n                break;\r\n            default:\r\n                string tempStr;\r\n                while (isdigit(exp[i])){\r\n                    tempStr += exp[i];\r\n                    i++;\r\n                }\r\n                i--; // 抵消for循环的一次递增\r\n                retExp.push_back(tempStr);\r\n                break;\r\n        }\r\n    }\r\n\r\n    while (opStack.top() != string(\"#\")){\r\n        retExp.push_back(opStack.top());\r\n        opStack.pop();\r\n    }\r\n\r\n    return retExp;\r\n}\r\n\r\n/*后缀表达式合理*/\r\nfloat evalRPN(vector<string> vecStr)\r\n{\r\n    stack<float> ret;\r\n    float num1, num2;\r\n    for (vector<string>::iterator iter = vecStr.begin(); iter != vecStr.end(); iter++) {\r\n        if (isdigit((*iter)[0]) || ((*iter)[0] == \'-\' && iter->size() > 1)) {\r\n            ret.push(float(atoi(iter->c_str())));\r\n        } else {\r\n            num2 = ret.top();\r\n            ret.pop();\r\n            num1 = ret.top();\r\n            ret.pop();\r\n            if (*iter == string(\"+\")) {\r\n                ret.push(num1 + num2);\r\n            } else if (*iter == string(\"-\")) {\r\n                ret.push(num1 - num2);\r\n            } else if (*iter == string(\"*\")) {\r\n                ret.push(num1 * num2);\r\n            } else if (int(num2) != 0){\r\n                ret.push(num1 / num2);\r\n            }\r\n        }\r\n    }\r\n    return ret.top();\r\n}\r\n\r\nint main()\r\n{\r\n    string exp(\"1+2*2+4\");\r\n    vector<string> vecStr = RBNExp(exp);\r\n    float ret = evalRPN(vecStr);\r\n    return 0;\r\n}\r\n```","timestamp":1571152866839}]