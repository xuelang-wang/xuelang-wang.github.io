if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m006']=[{"name":"001-逆波兰算法.md","path":"006-常用算法/001-逆波兰算法.md","content":"## 逆波兰算法\r\n\r\n### 中缀表达式转后缀表达式（逆波兰表达式）\r\n\r\n1. 从左至右扫描一中缀表达式。\r\n2. 若读取的是操作数，则判断该操作数的类型，并将该操作数存入操作数堆栈\r\n3. 若读取的是运算符\r\n\r\n    (1) 该运算符为左括号\"(\"，则直接存入运算符堆栈。 \r\n    \r\n    (2) 该运算符为右括号\")\"，则输出运算符堆栈中的运算符到操作数堆栈，直到遇到左括号\"(\"为止，此时抛弃该左括号。\r\n      \r\n    (3) 该运算符为非括号运算符：\r\n        \r\n        (a) 若运算符堆栈栈顶的运算符为左括号，则直接存入运算符堆栈\r\n      \r\n        (b) 若比运算符堆栈栈顶的运算符优先级高，则直接存入运算符堆栈。\r\n        \r\n        (c) 若比运算符堆栈栈顶的运算符优先级低或相等，则输出栈顶运算符到操作数堆栈，直至运算符栈栈顶运算符**低于（不包括等于）**该运算符优先级,或为左括号，\r\n           并将当前运算符压入运算符堆栈。\r\n4. 当表达式读取完成后运算符堆栈中尚有运算符时，则依序取出运算符到操作数堆栈，直到运算符堆栈为空。\r\n\r\n例子: 中缀表达式(a+b)*c-(a+b)/e的逆波兰式是ab+c*ab+e/\r\n\r\n### 逆波兰表达式求值\r\n\r\n1. 初始化一个栈S\r\n2. 从左到右遍历逆波兰表达式\r\n   1. 遇到操作数，则存到栈S中\r\n   2. 遇到操作符Op，则调用栈S中两个元素S[top-1] Op S[top], 计算结果存入栈S中\r\n3. 返回栈顶元素\r\n\r\n【练习】\r\n1. [150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation)\r\n2. [224. 基本计算器](https://leetcode-cn.com/problems/basic-calculator/)\r\n3. [227. 基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii/)\r\n\r\n### 算法实现\r\n\r\n#### c\r\n\r\n```c\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n#include<string.h>\r\n#include<ctype.h>\r\n\r\n#define STACK_NUM 200000\r\n#define NUM_LEN 12\r\n\r\nint Precode(const char ch)\r\n{\r\n    switch (ch) {\r\n        case \'+\':\r\n        case \'-\':\r\n            return 1;\r\n        case \'*\':\r\n        case \'/\':\r\n            return 2;\r\n        default:\r\n            return 0;\r\n    }\r\n}\r\n\r\n/*中缀表达式转后缀表达式(不考虑负数，且中缀表达式合理)*/\r\nchar **RPNExp(const char *exp, int len, int *outputLen)\r\n{\r\n\r\n    char **retExp = (char **)malloc(sizeof(char *) * STACK_NUM);\r\n    char opStack[STACK_NUM];\r\n    int top = 0, j;\r\n    opStack[top] = \'#\';\r\n    *outputLen = 0;\r\n    for (int i = 0; i < len; i++) {\r\n        switch (exp[i]) {\r\n            case \'(\':\r\n                opStack[++top] = \'(\';\r\n                break;\r\n            case \')\':\r\n                while(opStack[top] != \'(\') {\r\n                    *outputLen += 1;\r\n                    retExp[*outputLen - 1] = (char *)malloc(sizeof(char) * 2);\r\n                    retExp[*outputLen - 1][0] = opStack[top--];\r\n                    retExp[*outputLen - 1][1] = \'\\0\';\r\n                }\r\n                top--;\r\n                break;\r\n            case \'+\':\r\n            case \'-\':\r\n            case \'*\':\r\n            case \'/\':\r\n                while (Precode(opStack[top]) >= Precode(exp[i])) {\r\n                    *outputLen += 1;\r\n                    retExp[*outputLen - 1] = (char *)malloc(sizeof(char) * 2);\r\n                    retExp[*outputLen - 1][0] = opStack[top--];\r\n                    retExp[*outputLen - 1][1] = \'\\0\';\r\n                }\r\n                opStack[++top]  = exp[i];\r\n                break;\r\n            case \' \':\r\n                break;    \r\n            default:\r\n                *outputLen += 1;\r\n                retExp[*outputLen - 1] = (char *)malloc(sizeof(char) * NUM_LEN);\r\n                j = 0;\r\n                while (isdigit(exp[i])){\r\n                    retExp[*outputLen - 1][j++] = exp[i++];\r\n                }\r\n                retExp[*outputLen - 1][j] = \'\\0\';\r\n                i--; // 抵消for循环的一次递增\r\n                break;\r\n        }\r\n    }\r\n\r\n    while (opStack[top] != \'#\') {\r\n        *outputLen += 1;\r\n        retExp[*outputLen - 1] = (char *)malloc(sizeof(char) * 2);\r\n        retExp[*outputLen - 1][0] = opStack[top--];\r\n        retExp[*outputLen - 1][1] = \'\\0\';\r\n    }\r\n\r\n    return retExp;\r\n}\r\n\r\n\r\n/*后缀表达式合理*/\r\nint evalRPN(char **tokens, int tokensSize)\r\n{\r\n    int ret[STACK_NUM];\r\n    int top = -1;\r\n    int num1, num2;\r\n    for (int i = 0; i < tokensSize; i++) {\r\n        if (isdigit(tokens[i][0]) || (tokens[i][0] == \'-\' && strlen(tokens[i]) > 1)) {\r\n            ret[++top] = atoi(tokens[i]);\r\n        } else {\r\n            num2 = ret[top--];\r\n            num1 = ret[top--];\r\n            \r\n            if (tokens[i][0] == \'+\') {\r\n                ret[++top] = num1 + num2;\r\n            }\r\n            else if (tokens[i][0] == \'-\')\r\n            {\r\n                ret[++top] = num1 - num2;\r\n            }\r\n            else if (tokens[i][0] == \'*\')\r\n            {\r\n                ret[++top] = num1 * num2;\r\n            } else if (num2 != 0) {\r\n                ret[++top] = num1 / num2;\r\n            }\r\n        }\r\n    }\r\n    return ret[top];\r\n}\r\n\r\nint calculate(char *s)\r\n{\r\n    if (s == NULL || strlen(s) < 1) {\r\n        return 0;\r\n    }\r\n    int rpnLen = 0;\r\n    char **rpnEx = RPNExp(s, strlen(s), &rpnLen);\r\n    return evalRPN(rpnEx, rpnLen);\r\n}\r\n\r\nint main()\r\n{\r\n    char exp[] = \"1+2*2+4\"; // \"122*+4+\"\r\n    int Len = 0;\r\n    char **vecStr = RPNExp(exp, strlen(exp), &Len);\r\n    int ret = evalRPN(vecStr, Len);\r\n    return 0;\r\n}\r\n```\r\n\r\n#### c++\r\n\r\n```c++\r\n#include<iostream>\r\n#include<string>\r\n#include<stack>\r\n#include<vector>\r\n#include<stdlib.h>\r\n\r\nusing namespace std;\r\n\r\nint Precode(const char &ch)\r\n{\r\n    switch (ch) {\r\n        case \'+\':\r\n        case \'-\':\r\n            return 1;\r\n        case \'*\':\r\n        case \'/\':\r\n            return 2;\r\n        default:\r\n            return 0;\r\n    }\r\n}\r\n\r\n/*中缀表达式转后缀表达式(不考虑负数，且中缀表达式合理)*/\r\nvector<string> RBNExp(string exp)\r\n{\r\n\r\n    vector<string> retExp;\r\n    stack<string> opStack;\r\n    opStack.push(\"#\");\r\n    for (unsigned int i = 0; i < exp.size(); i++) {\r\n        switch (exp[i]) {\r\n            case \'(\':\r\n                opStack.push(\"(\");\r\n                break;\r\n            case \')\':\r\n                while(opStack.top() != string(\"(\")) {\r\n                    retExp.push_back(opStack.top());\r\n                    opStack.pop();\r\n                }\r\n                opStack.pop();\r\n                break;\r\n            case \'+\':\r\n            case \'-\':\r\n            case \'*\':\r\n            case \'/\':\r\n                while (Precode(opStack.top()[0]) >= Precode(exp[i])) {\r\n                    retExp.push_back(opStack.top());\r\n                    opStack.pop();\r\n                }\r\n                opStack.push(string(\"\") + exp[i]);\r\n                break;\r\n            default:\r\n                string tempStr;\r\n                while (isdigit(exp[i])){\r\n                    tempStr += exp[i];\r\n                    i++;\r\n                }\r\n                i--; // 抵消for循环的一次递增\r\n                retExp.push_back(tempStr);\r\n                break;\r\n        }\r\n    }\r\n\r\n    while (opStack.top() != string(\"#\")){\r\n        retExp.push_back(opStack.top());\r\n        opStack.pop();\r\n    }\r\n\r\n    return retExp;\r\n}\r\n\r\n/*后缀表达式合理*/\r\nfloat evalRPN(vector<string> vecStr)\r\n{\r\n    stack<float> ret;\r\n    float num1, num2;\r\n    for (vector<string>::iterator iter = vecStr.begin(); iter != vecStr.end(); iter++) {\r\n        if (isdigit((*iter)[0]) || ((*iter)[0] == \'-\' && iter->size() > 1)) {\r\n            ret.push(float(atoi(iter->c_str())));\r\n        } else {\r\n            num2 = ret.top();\r\n            ret.pop();\r\n            num1 = ret.top();\r\n            ret.pop();\r\n            if (*iter == string(\"+\")) {\r\n                ret.push(num1 + num2);\r\n            } else if (*iter == string(\"-\")) {\r\n                ret.push(num1 - num2);\r\n            } else if (*iter == string(\"*\")) {\r\n                ret.push(num1 * num2);\r\n            } else if (int(num2) != 0){\r\n                ret.push(num1 / num2);\r\n            }\r\n        }\r\n    }\r\n    return ret.top();\r\n}\r\n\r\nint main()\r\n{\r\n    string exp(\"1+2*2+4\");\r\n    vector<string> vecStr = RBNExp(exp);\r\n    float ret = evalRPN(vecStr);\r\n    return 0;\r\n}\r\n```","timestamp":1571676528511},{"name":"002-排列组合.md","path":"006-常用算法/002-排列组合.md","content":"# 排列与组合\r\n\r\n>1. [排列](#排列 \"排列\")\r\n\t1. [没有重复的全排列](#没有重复的全排列 \"没有重复的全排列\")\r\n\t1. [有重复的全排列](#有重复的全排列 \"有重复的全排列\")\r\n1. [组合](#组合 \"组合\")\r\n\t1. [没有重复元素的组合](#没有重复元素的组合 \"没有重复元素的组合\")\r\n\r\n## 排列\r\n\r\n### 没有重复的全排列\r\n\r\n一个包含n个不重复数字的数列的全排列，等于从中间任取一个数字（1~n）与剩下n-1个数字的数列的全排列和组合之和,为方便递归实现，把这个选取的数字与==当前第一个数字==交换。\r\n\r\n#### c\r\n```c\r\n```\r\n\r\n#### C++\r\n```c++\r\n#include<iostream>\r\n#include<vector>\r\n\r\nusing namespace std;\r\n\r\nvoid swap(int *num1, int *num2)\r\n{\r\n    if (num1 == num2) {\r\n        return; // 同一个地址直接返回\r\n    }\r\n    *num1 = (*num1) ^ (*num2);\r\n    *num2 = (*num1) ^ (*num2);\r\n    *num1 = (*num1) ^ (*num2);\r\n}\r\n\r\n// 递归实现（交换） 回溯\r\nvoid Permute1(vector<int>& nums, unsigned int current, vector<vector<int> > &ret)\r\n{\r\n    if (current == nums.size()) {\r\n        ret.push_back(nums);\r\n        return;\r\n    }\r\n    for (unsigned int i = current; i < nums.size(); i++) {\r\n        swap(&nums[i], &nums[current]);\r\n        Permute1(nums, current + 1, ret);\r\n        swap(&nums[i], &nums[current]);\r\n    }\r\n}\r\n\r\n\r\nvector<vector<int> > permute(vector<int>& nums)\r\n{\r\n    vector<vector<int> > ret;\r\n    if (nums.size() == 0) {\r\n        return ret;\r\n    }\r\n    Permute1(nums, 0, ret);\r\n    return ret;\r\n}\r\n\r\nint main()\r\n{\r\n    vector<int> nums = {1, 2, 3};\r\n    vector<vector<int> > ret = permute(nums);\r\n    return 0;\r\n}\r\n```\r\n\r\n### 有重复的全排列\r\n\r\n方法\r\n1. 先当作不重复，做全排列，最后对结果做去重。\r\n2. 增加一个标记数组，记录当前数字是否重复放过。\r\n\r\n\r\n练习\r\n1. [46 全排列](https://leetcode-cn.com/problems/permutations)\r\n\r\n## 组合\r\n\r\n给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合\r\n\r\n### 没有重复元素的组合\r\n\r\n从左到右遍历，对于当前数组，分两种情况，选择这个元素还是不选这个元素；\r\n\r\n#### c++\r\n\r\n```c++\r\n#include<iostream>\r\n#include<vector>\r\n\r\nusing namespace std;\r\n\r\nvoid Combine1(int n, int k, int current, vector<int> &temp, vector<vector<int> > &ret)\r\n{\r\n    if (current > n + 1) {\r\n        return;\r\n    }\r\n    if (temp.size() == k) {\r\n        ret.push_back(temp);\r\n        return;\r\n    }\r\n    temp.push_back(current);\r\n    Combine1(n, k, current + 1, temp, ret);\r\n    temp.pop_back();\r\n    Combine1(n, k, current + 1, temp, ret);\r\n}\r\n\r\nvector<vector<int>> combine(int n, int k)\r\n{\r\n    vector<vector<int> > ret;\r\n    vector<int> temp;\r\n    if (k < 1 || k > n) {\r\n        return ret;\r\n    }\r\n    Combine1(n, k, 1, temp, ret);\r\n    // Combine2(n, k, ret);\r\n     return ret;\r\n}\r\n\r\nint main()\r\n{\r\n    vector<vector<int> > ret = combine(4, 2);\r\n    return 0;\r\n}\r\n```\r\n\r\n#### 0-1组合（非递归）\r\n\r\n初始化一个N长度的0-1数组（1表示，选择相应下标的元素，0 则相反），前k个初始为1，按下面规则进行移位：\r\n1. 寻找第一个出现10，交替位置，并把前面出现的1全部移到最前面，从头开始排列，输出一种组合\r\n2. 重复第一步，直到找不到10\r\n\r\n```\r\n// 举例  C(4,2) \r\n1 1 0 0 ==> 1,2\r\n1 0 1 0 ==> 1,3\r\n0 1 1 0 ==> 2,3\r\n1 0 0 1 ==> 1,4\r\n0 1 0 1 ==> 2 4\r\n0 0 1 1 ==> 3,4\r\n```\r\n\r\n```c++\r\nvector<int> GetOneCombine(vector<int> &temp)\r\n{\r\n    vector<int> ret;\r\n    for (int i = 0; i < int(temp.size()); i++) {\r\n        if (temp[i] == 1) {\r\n            ret.push_back(i + 1);\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n\r\nbool NextCombine(vector<int> &temp)\r\n{\r\n    int NumOfOne = 0;\r\n    for (int i = 0; i < int(temp.size())  - 1; i++) {\r\n        if (temp[i] == 1) {\r\n            NumOfOne++;\r\n        }\r\n        if (temp[i] == 1 && temp[i + 1] == 0) {\r\n            NumOfOne--;\r\n            temp[i] = 0;\r\n            temp[i + 1] = 1;\r\n            for (int j = 0; j < i; j++) {\r\n                temp[j] = (j < NumOfOne ? 1 : 0);\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nvoid Combine2(int n, int k, vector<vector<int> > &ret)\r\n{\r\n    vector<int> temp(vector<int>(n,0));\r\n    for (int i = 0; i < k; i++) {\r\n        temp[i] = 1;\r\n    }\r\n    ret.push_back(GetOneCombine(temp));\r\n    while (NextCombine(temp)) {\r\n        ret.push_back(GetOneCombine(temp));\r\n    }\r\n}\r\n```\r\n\r\n练习\r\n1. [77 组合](https://leetcode-cn.com/problems/combinations/)","timestamp":1571676528511},{"name":"003-字符串算法.md","path":"006-常用算法/003-字符串算法.md","content":"# 字符串算法\r\n\r\n>1. [最短回文串](#最短回文串 \"最短回文串\")\r\n\t1. [](# \"\")\r\n\t1. [c](#c \"c\")\r\n1. [至少k个重复字符的最长子串](#至少k个重复字符的最长子串 \"至少k个重复字符的最长子串\")\r\n\t1. [递归](#递归 \"递归\")\r\n\t1. [c实现](#c实现 \"c实现\")\r\n\r\n## 最短回文串 \r\n\r\n给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。\r\n\r\n```\r\n// 例子\r\n1. \"aacecaaa\" ===> \"aaacecaaa\"\r\n2. \"abcd\"     ===> \"abcdcba\"\r\n```\r\n\r\n### \r\n\r\n### c\r\n\r\n```c\r\n\r\n```\r\n\r\n## 至少k个重复字符的最长子串\r\n\r\n找到给定字符串（由小写字符组成）中的最长子串 T ， 要求 T 中的每一字符出现次数都不少于 k 。输出 T 的长度。\r\n\r\n示例\r\n```\r\n输入:\r\ns = \"ababbc\", k = 2\r\n\r\n输出:\r\n5\r\n\r\n最长子串为 \"ababb\" ，其中 \'a\' 重复了 2 次， \'b\' 重复了 3 次。\r\n```\r\n\r\n### 递归\r\n\r\n1. 遍历字符串s, 统计字符出现次数\r\n2. 注意剪枝，两端不符合要求的字符可以去掉\r\n3. 从头遍历字符串s, 若当前字符ch出现次数count(ch)小于k，则将字符s以字符ch为界，切分为两个字符子串s1,s2,递归s1和s2;若整个字符串s中的字符都满足，则返回字符串长度。\r\n\r\n### c实现\r\n\r\n```c\r\n#include<stdio.h>\r\n#include<string.h>\r\n\r\n#define NUM 26\r\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\r\n\r\nint longestSubstringRA(char *s, int start, int end, int k)\r\n{\r\n    int i, j;\r\n    int count[NUM] = {0};\r\n\r\n    if (s == NULL || (end - start) < k) {\r\n        return 0;\r\n    }\r\n    for (i = start; i < end; i++) {\r\n        count[s[i] - \'a\']++;\r\n    }\r\n\r\n    while (end - start >= k && count[s[start] - \'a\'] < k) {\r\n        start++;\r\n    }\r\n    while (end - start >= k && count[s[end - 1] - \'a\'] < k) {\r\n        end--;\r\n    }\r\n    if (end - start < k) {\r\n        return 0;\r\n    }\r\n    \r\n    for (i = start; i < end; i++) {\r\n        if (count[s[i] - \'a\'] < k) {\r\n            return MAX(longestSubstringRA(s, start, i, k), longestSubstringRA(s, i + 1, end, k));\r\n        }\r\n    }\r\n    return (int)(end - start);\r\n}\r\n\r\nint longestSubstring(char *s, int k)\r\n{\r\n    return longestSubstringRA(s, 0, strlen(s), k);\r\n}\r\n\r\nint main()\r\n{\r\n    char *s = \"aaaaaaaaaaaaaaaabbbbbbbbbbbbaaaaaaabbbbbbbbbbbbcccccccccccdddddddddddddddddddeeeeeeeeeeeeeeefffffffffffffffgggggggggggggggggggghhhhhhhhhhhhhhhhiiiiiiiiiiiiiiiiiiiiiijjjjjjjjjjjjjjjjjjjjjjjjkkkkkkkkkkkkkkkkkkkk\";\r\n    int ret = longestSubstring(s, 10);\r\n    return 0;\r\n}\r\n```\r\n\r\n\r\n","timestamp":1571676528511}]